스마트 포인터 : 동적 메모리 관리를 단순화 하기 위한 도구

동적 메모리 할당 시 발생할 문제점
- 메모리 누수 (new를 통해 할당 후 delete 안 함 등)
- Dangling Pointer (해제한 메모리를 참조하려고 할 때)
- Double Free(한 번 해제된 메모리를 다시 해제할 시)
- 메모리 손상

스마트 포인터를 이용하면 해당 문제점을 자동으로 관리해주기 때문에 실수를 줄일 수 있음

1. unique_ptr : 소유권을 명확히 하는 스마트 포인터로 한 객체는 오직 하나의 unique_ptr만 소유할 수 있음

특징
- 유일한 소유권
동일한 객체를 2개 이상의 unique_ptr이 소유할 수 없음

- 복사 불가능
std::unique_ptr<MyClass> UP = std::make_unique<MyClass>();
std::unique_ptr<MyClass> UP2 = UP;			// 컴파일 오류

std::unique_ptr<MyClass> UP3 = std::move(UP);	// 소유권 이동

- 자동 메모리 해제
선언된 지역이 끝날경우 해당 메모리는 자동으로 반환되기 때문에 delete를 따로 호출해줄 필요가 없음

2. shared_ptr : 참조 카운터(reference count)를 통해 여러 개의 소유자가 하나의 자원을 공유하며 해당 카운터가 0가 되지 않는 한 메모리에서 반환되지 않는다.

특징
- 참조 카운팅
해당 객체를 참조하는 소유자의 개수를 뜻하고 복사나 이동 시 소유자가 늘어나면 카운트 개수가 증가한다.
해당 카운트 수가 0이 되면 해당 객체는 자동으로 메모리에서 삭제된다.

주의점
- 쓰레드
다중 쓰레드 환경에서 사용 시 동기화기 필요

- 순환 참조
두 객체가 서로를 참조할 경우 reference count가 0이 되지 않아 메모리 누수가 발생한다.

3. weak_ptr : shared_ptr의 순환참조 문제를 해결하기 위한 포인터로 Reference Count에 영향을 미치지 않는 포인터이다.
특징
- 소유권 X
weak_ptr은 shared_ptr처럼 객체를 소유하지 않기 때문에 Reference Count에 영향을 끼치지 않기 때문에 순환참조 문제를 해결할 수 있다.
해당 포인터는 객체를 관찰하는 역할만 하며 객체가 존재하지 않으면 자동으로 nullptr로 변함
lock() 메서드를 통해 해당 객체가 존재하는지 여부를 파악한 후 사용한다.