STL(C++ Standard Templete Library) : C++에서 이미 만들어진 템플릿을 이용하기 위해 불러와 사용하는 것

STL은 크게 컨테이너, 반복자, 알고리즘 3가지로 나눌 수 있음

- 컨테이너 : 자료를 저장하는 클래스 템플릿들의 집합

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
시퀸스 컨테이너 : 데이터를 선형적으로 저장하는 컨테이너
ex) vector, list, deque, array, forward_list 등

- vector : 
 : stl에서 제공하는 배열형 시퀸스 컨테이너의 한 종류로 동적 배열을 구현한 컨테이너
vector는 메모리를 연속적으로 할당하기 때문에 데이터에 접근성이 빠르다는 장점이 있음
다만 vector의 크기가 변동 시 기존 데이터를 새로운 위치에 재할당하는 비용이 발생한다는 단점이 존재

- list
 : stl에서 제공하는 노드형 시퀸스 컨테이너의 한 종류로 이중 연결 리스트를 구현한 컨테이너
이중 연결리스트란? 각 노드가 이전 노드와 다음 노드에 대한 참조를 갖는 자료구조
list는 임의의 위치에서의 삽입 삭제가 상수 시간에 가능하다는 장점이 존재
다만 vector와 달리 메모리를 연속적으로 할당하지 않기 때문에 인덱스를 통한 랜덤 접근이 불가하다는 단점이 존재

- forward_list
 : stl에서 제공하는 노드형 시퀸스 컨테이너로 단방향 연결 리스트를 구현한 컨테이너

- deque
 : 양쪽 끝에서 삽입 삭제가 모두 가능한 stl의 배열형 시퀸스 컨테이너
vector와 마찬가지로 데이터를 연속적으로 저장하지만, 앞 뒤로 삽입 및 삭제가 가능하고 메모리 블록 단위로 관리하기 때문에 재할당이 이루어지지 않는다는 장점이 존재
다만 중간 위치에 있는 원소에 접근하는 것은 비교적 느린 편이며 메모리 할당도 vector보다 불규칙적이라는 단점이 존재

vector보다 메모리 할당이 불규칙적인 이유?
deque는 메모리 블록단위로 할당을 받는데 이때 메모리 블록은 연속적으로 존재하지 않기 때문

- array
 : stl에서 제공하는 배열형 시퀸스 컨테이너로 고정된 크기의 배열을 제공(크기는 컴파일 타임에 결정되어야 함)
C 스타일 배열과 비슷하나 stl 컨테이너 들이 가지는 여러 편리한 메서드와 멤버함수를 제공받을 수 있음
다만 크기가 정해져 있어야 해서 vector보다 활용도가 낮음(별로 안 써봄)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
컨테이너 어댑터 : 기본 STL 컨테이너를 특정 데이터 구조나 추상화에 맞게 변형하여 사용하는 어댑터
ex) stack, queue, priority_queue 등

- stack
 : 데이터를 LIFO(Last In First Out) 방식으로 저장하는 stl의 컨테이너 어댑터
기본 내부 컨테이너는 deque
가장 최근에 저장된 요소가 가장 먼저 추출되는 특징을 가지고 이는 컴퓨터의 메모리 구조와 비슷하게 작동(프로그램의 함수 호촐 스택에서 볼 수 있음)
재귀함수를 구현할 때 또는 후위 표기법 계산 등 여러 알고리즘에서 사용됨

- queue
 : 데이터를 FIFO(First In First Out) 방식으로 저장하는 stl의 컨테이너 어댑터
기본 내부 컨테이너는 deque
가장 나중에 저장된 요소가 가정 먼저 추출되는 특징을 가짐
스케줄링, 이벤트 드리븐 프로그래밍, 캐시 알고리즘 등 다양한 알고리즘에서 사용됨

- priority_queue
 : 저장된 요소를 우선순위에 따라 저장하고 관리하는 특징을 가진 stl의 컨테이너 어댑터(기본적으로 'less'연산자를 이용하여 요소를 비교 - 큰 값이 높은 우선순위)
기본 내부 컨테이너는 vector

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
연관 컨테이너 : Key를 기반으로 요소를 저장하고 조회하는 컨테이너
ex) map, set, multimap, multiset 등

- set : Key의 유일성을 보장하는 노드형 연관 컨테이너(동일한 값 X)
저장된 요소는 기본적으로 오름차순으로 정렬(내림차순 혹은 사용자 정의 비교 함수를 변경 가능)

- map : Key와 Value의 쌍을 요소로 가지는 노드형 연관 컨테이너로 중복 Key를 허용하지 않음(Value는 겹쳐도 상관 없음)
저장된 요소는 Key를 기준으로 정렬됨(검색, 제거, 삭제 작업이 로그시간에 수행되도록 보장)

- multiset : set과 유사하나 중복 Key를 허용하는 노드형 연관 컨테이너
저장된 요소는 set과 마찬가지로 정렬됨(정렬 기준은 사용자가 변경이 가능)

- multimap : map과 유사하나 중복키를 허용하는 노드형 연관 컨테이너
저장된 요소는 Key를 기준으로 정렬됨(정렬 기준은 사용자가 변경이 가능)

equal_range() -> 동일한 키를 가진 요소를 액세스 하기 위한 함수(multiset, multimap 둘다 사용)
반환값 : multiset -> std::pair<std::multiset<KeyType>::iterator, std::multiset<KeyType>::iterator>
	    multimap -> std::pair<std::multimap<KeyType, ValueType>::iterator, std::multimap<KeyType, ValueType>::iterator>
해당 pair의 first는 액세스를 위한 Key값의 시작 위치, second는 Key값의 마지막 위치

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
해시 기반 컨테이너 : 해시 테이블을 사용하여 데이터를 저장하는 연관 컨테이너
ex) unordered_map, unordered_set, unordered_multimap, unordered_multiset 등

- unordered_set : set과 동일하게 유일한 Key를 보장하지만 내부적으로 해시테이블을 사용해 값들을 저장하는 컨테이너

- unordered_map : map과 동일하게 중복 Key를 허용하지 않고 내부적으로 해시테이블을 사용해 값들을 저장하는 컨테이너

- unordered_multiset : unordered_set과 동일하지만 중복 Key를 허용하는 컨테이너

- unordered_multimap : unordered_map과 동일하지만 중복 Key를 허용하는 컨테이너

해시 테이블을 통해 값을 저장하기 때문에 순서를 보장하지 않음(주의점 : 원소를 순회할 때 순서가 변경될 가능성이 존재)
